1
00:00:04,949 --> 00:00:09,948
<v ->接下来我们想要获取数据并将其反序列化 (Deserialize)</v>

2
00:00:10,180 --> 00:00:13,270
到我们的模型之中。

3
00:00:14,481 --> 00:00:16,695
然而，在这么做之前，我们需要

4
00:00:16,696 --> 00:00:19,034
调用漫威动画的接口。为了达成这个目标

5
00:00:19,035 --> 00:00:21,889
我们需要知道怎么去生成一个 MD5 哈希值。

6
00:00:21,890 --> 00:00:24,949
而且我不跟你开玩笑地说，我对此毫无想法。

7
00:00:24,950 --> 00:00:29,628
如果不是有人在网上发了参考代码，我可能就不知道怎能计算这个了。

8
00:00:29,629 --> 00:00:36,568
这是2015/2016年的软件开发之美，与学习相反

9
00:00:36,569 --> 00:00:41,331
它回到了我在互联网诞生之前所做的事情（如果你能想象的话）

10
00:00:41,332 --> 00:00:47,211
但是说回来，如果你想学习更多东西，我会告诉你答案

11
00:00:47,212 --> 00:00:51,091
我很高兴把你带领到那里（指答案处）

12
00:00:51,092 --> 00:00:57,590
让我们从大致了解我们需要在我们的 GetCharacterList() 里所做的事情开始。

13
00:00:57,591 --> 00:01:06,221
我们需要组装我们所用于调用的 URL

14
00:01:06,222 --> 00:01:11,217
以获得其 MD5 哈希值。

15
00:01:11,218 --> 00:01:14,767
然后我们将调用 API

16
00:01:14,768 --> 00:01:18,250
并得到一个（来自 API 的）回复

17
00:01:18,251 --> 00:01:25,332
然后我们需要将回复转换到一个字符串

18
00:01:25,333 --> 00:01:29,796
这个字符串代表 JSON 数据

19
00:01:29,797 --> 00:01:32,876
也就是我们想要反序列化 (Deserialize) 的

20
00:01:32,877 --> 00:01:42,775
如果你想回忆一下我们反序列化 (Deserialize) JSON 数据的方法

21
00:01:42,776 --> 00:01:46,016
那就是使用 DataContractJsonSerializer 。

22
00:01:47,107 --> 00:01:49,775
但是这可能会有些麻烦

23
00:01:49,776 --> 00:01:52,234
我们需要探究一二。

24
00:01:52,746 --> 00:01:56,564
组装请求用的 URL 是很简单的事情

25
00:01:56,565 --> 00:02:05,113
让我们返回我们的互动式 API 文档

26
00:02:05,114 --> 00:02:09,509
并再次运行我们所需要的这类查询

27
00:02:09,510 --> 00:02:16,695
就像之前给定一个随机差值（比如100），并只返回十个结果

28
00:02:16,696 --> 00:02:19,073
我们点击 “试一下” (Try out) 按钮，它应该返回给我们

29
00:02:20,114 --> 00:02:24,876
我们需要使用的请求 URL 格式。

30
00:02:28,508 --> 00:02:31,287
我们需要的也就是请求 URL 本体。

31
00:02:31,288 --> 00:02:38,968
我将选中这个 URL 并复制回去，我们将创建一个名叫 URL 的字符串类型变量 (string URL)

32
00:02:40,047 --> 00:02:42,126
初始值等于(equals) String.Format() 返回的结果。

33
00:02:42,127 --> 00:02:46,920
然后我们将复制这个长 URL 。

34
00:02:46,921 --> 00:02:51,920
接下来我们要在这里创造更多的空间（空格）

35
00:02:52,551 --> 00:02:56,711
然后把这里硬编码为10

36
00:02:56,712 --> 00:03:00,211
如果你愿意，你可以把这个数值替换为

37
00:03:00,212 --> 00:03:04,111
15, 20 或者 100，总之可以是任意你想要的数字。

38
00:03:04,112 --> 00:03:08,070
我们将要变更这个偏差值

39
00:03:08,071 --> 00:03:10,890
与此同时也更换 API 密钥

40
00:03:10,891 --> 00:03:18,100
然后我们将在 （这个 URL ）最后附加哈希。（我们将在后面讨论哈希）

41
00:03:18,992 --> 00:03:21,511
接下来我们要做的第一件事情

42
00:03:21,512 --> 00:03:24,677
是创建随机类 (Random) 的一个实例

43
00:03:28,979 --> 00:03:33,978
我们将用它来取得新的偏差值。

44
00:03:34,439 --> 00:03:37,659
我偶然得知这里一共有1500个角色

45
00:03:37,660 --> 00:03:39,619
我将在这里硬编码

46
00:03:39,620 --> 00:03:41,819
但是我可能应当在某个合适的时机将它填到一个常量里。

47
00:03:41,820 --> 00:03:46,819
所以我们把这个变量称之为 offset

48
00:03:47,109 --> 00:03:57,958
初始值等于 random.Next() ，我将给定其可以生成的随机值上限为1500。

49
00:03:59,648 --> 00:04:02,904
一旦我得到了偏差值

50
00:04:02,905 --> 00:04:06,385
我就可以在这里 （URL） 中提供。

51
00:04:06,386 --> 00:04:09,085
接下来我要做的是提供 API 密钥

52
00:04:09,086 --> 00:04:13,325
我目前要完成的是

53
00:04:13,326 --> 00:04:16,565
创建一组私有常量。

54
00:04:16,566 --> 00:04:21,565
名叫 私钥(PrivateKey) 的私有访问 (private) 的字符串类型 (string) 常量 (const)

55
00:04:21,756 --> 00:04:31,352
接下来是另一个叫公钥的私有常量

56
00:04:31,353 --> 00:04:35,775
接下来我将创建另一个

57
00:04:35,776 --> 00:04:40,775
名叫 MaxCharacters 的私有访问整数常量

58
00:04:42,982 --> 00:04:46,930
值等于 1500 ， 接下来 and we'll just do MaxCharacters

59
00:04:49,501 --> 00:04:53,600
然后我们会在这里填入公钥。

60
00:04:54,941 --> 00:04:57,080
接下来我们要做的是

61
00:04:57,081 --> 00:04:59,960
真正地枚举公私钥。

62
00:05:00,971 --> 00:05:11,340
这也就是和我的个人信息（指账号）密切相关的东西，我将在完成录制这一系列视频后删除我的账号。

63
00:05:11,341 --> 00:05:14,180
所以这个密钥将不会工作，你得自己去申请一个。

64
00:05:14,181 --> 00:05:15,721
不要试图复制我的密钥。

65
00:05:15,722 --> 00:05:24,359
将公私钥分别填在对应的地方。

66
00:05:28,779 --> 00:05:30,818
接下来我们要做的是

67
00:05:30,819 --> 00:05:35,818
真正计算获得 MD5 哈希值

68
00:05:36,892 --> 00:05:44,739
我知道我目前需要做的是创建一个静态私有的方法 (private static)

69
00:05:44,740 --> 00:05:49,619
这个叫做 CreateHash() 的方法将会返回一个字符串。

70
00:05:49,620 --> 00:05:59,113
让我们创建一个叫 toBeHashed 的变量，等于……

71
00:06:00,234 --> 00:06:04,077
我们需要一个时间戳和私钥

72
00:06:05,678 --> 00:06:07,527
以及公钥。

73
00:06:08,685 --> 00:06:11,404
我们将把这三者合并起来。

74
00:06:11,405 --> 00:06:15,704
说到时间戳的话，如果你仔细阅读了文档

75
00:06:15,705 --> 00:06:20,084
在 “如何” (How To) 章节的授权子章节下面

76
00:06:20,085 --> 00:06:24,344
文档表示时间戳可以使用任意长字符串

77
00:06:24,345 --> 00:06:27,624
随着请求而变更。

78
00:06:27,625 --> 00:06:29,564
因此你没有为此抓狂。

79
00:06:29,565 --> 00:06:32,404
我将使用 DateTime.Now.Ticks

80
00:06:32,405 --> 00:06:34,384
它将给我们一个（随时间）唯一的字符串

81
00:06:34,385 --> 00:06:39,804
代表从过去的某一时间点开始计算已经过去了多少毫秒。

82
00:06:39,805 --> 00:06:46,644
所以我们创建一个叫 timestamp 的变量，初始值等于 DateTime.Now.Ticks.ToString() 。

83
00:06:48,144 --> 00:06:50,153
这样就应该好了。

84
00:06:50,804 --> 00:06:52,223
接下来我要做的是

85
00:06:52,224 --> 00:06:54,403
真正计算哈希。

86
00:06:54,404 --> 00:06:58,243
问题是我对怎么完成这个毫无头绪。

87
00:06:58,244 --> 00:07:03,243
难道没有人在伟大的互联网上

88
00:07:03,664 --> 00:07:06,003
找到了解决方案

89
00:07:06,004 --> 00:07:09,762
并慷慨地在 StackOverflow 的某个问题下添加回复吗？

90
00:07:09,763 --> 00:07:14,148
我将给你这个问题的 URL 。

91
00:07:14,149 --> 00:07:17,868
我大致花了三天时间尝试学习

92
00:07:17,869 --> 00:07:20,968
如何创建我自己的哈希，我学到了很多

93
00:07:20,969 --> 00:07:30,608
但最终我并没有成功创建一个可以工作的实现，因此我从互联网上剽窃了有关这些内容的五行代码。

94
00:07:30,609 --> 00:07:38,068
我接下来将检查所有程序集引用 (Reference) 已经使用 using 语句添加，在此，我想推荐

95
00:07:38,109 --> 00:07:41,303
如果你真的想学习这些东西是怎么工作的

96
00:07:41,304 --> 00:07:53,174
在 MicrosoftVirtualAcademy.com 上有很多关于安全的东西可供你查看。

97
00:07:53,175 --> 00:07:54,475
也许在那里有一些不错的书籍。

98
00:07:54,476 --> 00:07:56,795
去 MSDN 上看看这里每一个引用的对象

99
00:07:56,796 --> 00:08:00,675
和每一个对象里的方法

100
00:08:00,676 --> 00:08:02,415
了解它们的用法和使用原理，是有显著好处的。

101
00:08:02,416 --> 00:08:05,435
但是在这天的末尾，我只关心

102
00:08:05,436 --> 00:08:09,243
计算给定值的 MD5 哈希值

103
00:08:09,244 --> 00:08:12,423
然后我得到的是正确的 MD5 哈希值。

104
00:08:14,274 --> 00:08:18,893
变量 hashedMessage 等于……

105
00:08:19,754 --> 00:08:25,598
computeMD5() 方法的返回值，我将在这里传入要被哈希的内容，然后返回

106
00:08:25,599 --> 00:08:30,058
被哈希的内容。

107
00:08:30,059 --> 00:08:35,058
然后我们就获得了哈希。

108
00:08:35,139 --> 00:08:42,583
新建 hash 变量，初始值等于 CreateHash

109
00:08:44,294 --> 00:08:54,570
然后我要 附上已经存在的请求 URL

110
00:08:54,571 --> 00:08:58,749
还有哈希值

111
00:08:58,750 --> 00:09:00,490
啊对，就是哈希值和时间戳

112
00:09:00,491 --> 00:09:02,350
因为这样就包含它所需要的所有东西了。

113
00:09:02,351 --> 00:09:06,210
所以，我将输入……字符串(String)

114
00:09:07,061 --> 00:09:09,075
啊，我觉得我可以通过相当多样的方法来处理这个东西。

115
00:09:09,076 --> 00:09:10,675
让我们继续，在一步内完成这些事情。

116
00:09:10,676 --> 00:09:12,575
（事实上，我改变想法了）

117
00:09:12,576 --> 00:09:17,183
我们要先做那一步，然后创建 URL 。

118
00:09:17,184 --> 00:09:19,403
在 URL 的末尾，我将加上

119
00:09:19,404 --> 00:09:24,043
加入时间戳等于……并稍后替换进去(使用String.Format方法)

120
00:09:24,044 --> 00:09:29,035
然后是哈希等于……好了。

121
00:09:32,246 --> 00:09:38,027
然后，为了获得（哈希），我需要传入时间戳。

122
00:09:38,638 --> 00:09:43,257
不幸的是，我需要在这里更改一些内容。

123
00:09:43,258 --> 00:09:45,587
创建字符串参数 timestamp

124
00:09:46,798 --> 00:09:48,477
然后传进去。

125
00:09:50,558 --> 00:09:54,577
但是我需要在这里能够访问

126
00:09:57,828 --> 00:10:00,286
然后稍后也能传入它。

127
00:10:01,197 --> 00:10:03,526
时间戳解决了，很好。

128
00:10:05,137 --> 00:10:12,813
接下来我将使用 HTTP 客户端 (HttpClient)

129
00:10:16,504 --> 00:10:19,860
命名为 http ，然后我需要使用 using 语句来声明使用它。

130
00:10:19,861 --> 00:10:27,819
using System.Net.Http 等于 new HttpClient

131
00:10:27,820 --> 00:10:36,579
这将允许我们在代码中直接使用 http.GetAsync() 方法来传入请求 URI (requestURI)，

132
00:10:36,580 --> 00:10:43,320
把 URL 给它，我得到的返回内容应该是一个可等待的对象。

133
00:10:43,321 --> 00:10:54,726
我从可等待对象得到的返回结果应当是 HttpResponseMessage 类型的。

134
00:10:54,727 --> 00:10:55,975
我注意到你得到了红色波浪线

135
00:10:55,976 --> 00:11:01,235
这是因为你需要在这里添加异步 (async) 关键字

136
00:11:01,236 --> 00:11:04,719
我觉得这就是你目前需要做的所有事情，等一下我们会回来的。

137
00:11:04,720 --> 00:11:06,078
好，我们继续。

138
00:11:06,079 --> 00:11:09,379
我们得到了返回的内容

139
00:11:09,380 --> 00:11:12,736
我需要把返回的内容阅读到一个字符串里。

140
00:11:12,737 --> 00:11:16,723
创建字符串变量  jsonMessage ，等于

141
00:11:16,724 --> 00:11:25,573
等于 response.Content ，啊不，Content.ReadAsStringAsync() ,它将给我们

142
00:11:26,212 --> 00:11:28,325
JSON 消息本体。

143
00:11:28,326 --> 00:11:33,536
我有它在手了。因为这个方法是异步的，我要把这个声明为等待 (awaitable) 的操作。

144
00:11:35,067 --> 00:11:43,329
接下来我要把返回的 JSON 消息反序列化到我的类中。

145
00:11:43,330 --> 00:11:49,868
我将使用 DataContractJsonSerializer 完成这件事情

146
00:11:50,320 --> 00:11:54,261
我们已经在项目中引用了相关的库。

147
00:11:54,262 --> 00:12:01,242
我将点击弹出的浮动菜单并添加对 System.Runtime.Serialization.Json 命名空间的引用。

148
00:12:02,472 --> 00:12:08,252
这样它就能被识别了，接下来我将创建序列器 (Serializer)

149
00:12:09,503 --> 00:12:13,328
也就是一个新的 DataContractJsonSerializer 类实例

150
00:12:13,329 --> 00:12:26,921
指定类型是角色数据的包装类 (Character data wrapper) : CharacterDataWrapper 。

151
00:12:26,922 --> 00:12:27,481
现在为什么我没有看到它呢？

152
00:12:27,482 --> 00:12:31,500
因为我没有为模型类添加 using 引用声明。

153
00:12:31,501 --> 00:12:36,160
所以 using HeroExplorer.Models 声明应当解决引用问题。

154
00:12:38,371 --> 00:12:46,387
接下来我需要一个内存流对象 (MemoryStream) 。哎呀， 给内存流命名ms（而不是me）。

155
00:12:48,968 --> 00:12:51,188
让我们确保我们为其添加了 using 声明。

156
00:12:51,189 --> 00:12:59,847
(using) System.IO ， 我们将在内存流中堆一些东西

157
00:12:59,848 --> 00:13:03,947
内存流将存着我们需要的信息，接下来我们将把它们

158
00:13:03,948 --> 00:13:10,088
传给序列器，序列器会从内存流中把东西取出，然后反序列化

159
00:13:10,089 --> 00:13:19,148
并最后将其从 CharacterDataWrapper 的根节点开始，以对象的形式传回给我们。

160
00:13:19,149 --> 00:13:26,645
所以我们需要以设置编码为 Encoding.UTF8 开始

161
00:13:26,646 --> 00:13:30,767
也就是我们预期中的 JSON 的编码格式

162
00:13:30,768 --> 00:13:33,847
然后将字节取出

163
00:13:36,128 --> 00:13:44,276
简单地把这串 JSON 信息字符串转换到一个基于 UTF-8 编码的字节数组

164
00:13:44,277 --> 00:13:46,277
然后把它们放到内存流里。

165
00:13:46,278 --> 00:13:50,306
然后这就应该是一个新的内存流了。

166
00:13:51,576 --> 00:14:00,915
然后，如果我们把这么多繁杂的事情做好，我们就应该处理内存中的对象

167
00:14:02,066 --> 00:14:14,814
我们将把其读入一个叫 result 的变量中

168
00:14:15,402 --> 00:14:28,932
如果一切良好，我们应该得到 CharacterDataWrapper 类的对象。 就这样。

169
00:14:29,661 --> 00:14:32,320
接下来如果我们想让其工作的话

170
00:14:32,321 --> 00:14:44,780
我们需要用一个 CharacterDataWrapper 类的实例 (Task<CharacterDataWrapper>) 来返回我们想要的结果。

171
00:14:47,831 --> 00:14:52,857
为什么大家不高兴呢？因为你目前的返回类型是 void 。

172
00:14:52,858 --> 00:14:55,318
现在万事看上去正常，大家都很高兴，对吧？

173
00:14:55,319 --> 00:14:57,338
编译解决方案。

174
00:15:05,239 --> 00:15:06,753
很好，编译通过了。

175
00:15:07,584 --> 00:15:10,893
接下来我们要做的，

176
00:15:11,904 --> 00:15:16,693
让我看看……在我们的 MainPage.xaml 里

177
00:15:16,694 --> 00:15:19,753
我将添加一个按钮，当我们点击它的时候

178
00:15:19,754 --> 00:15:21,153
整个流程将会启动。

179
00:15:21,154 --> 00:15:23,793
我只是想验证它是不是将我所需要的数据返回了。

180
00:15:23,794 --> 00:15:26,673
一旦我们获得了数据，然后将其反序列化

181
00:15:26,674 --> 00:15:28,873
我们就可以开始用户界面的工作。

182
00:15:28,874 --> 00:15:40,043
但与此同时，我希望确认一下我们有能力进行下去（走得更远）。

183
00:15:42,523 --> 00:15:47,522
所以我希望调用一下 MarvelFacade 。

184
00:15:48,463 --> 00:15:52,392
啊呀，为什么不是我想看到的东西呢……

185
00:15:52,743 --> 00:15:57,742
因为我需要使其为静态类型。好了。

186
00:16:00,034 --> 00:16:02,802
使用静态类型后，我就不需要创建 MarvelFacade 的实例了。

187
00:16:02,803 --> 00:16:07,822
我不需要为让它带回一点东西而创建一个引用实例。

188
00:16:07,823 --> 00:16:09,482
你知道，它并没有任何状态。

189
00:16:10,203 --> 00:16:12,731
所以目前它应该工作了。

190
00:16:12,732 --> 00:16:17,731
创建一个叫 data 的变量，使其值等于调用上述方法的返回值。

191
00:16:18,079 --> 00:16:19,947
这就是我想做的所有事情。

192
00:16:21,258 --> 00:16:24,617
让我在这里创建一个断点 (Breakpoint)

193
00:16:25,758 --> 00:16:29,106
呀，点在了我所担心的地方。

194
00:16:29,107 --> 00:16:31,886
我非常自信一切正常。

195
00:16:31,887 --> 00:16:40,074
我对这儿有一点儿担心，但我不能解释原因。

196
00:16:40,075 --> 00:16:42,943
让我们看看它会不会工作。

197
00:16:46,914 --> 00:16:56,320
如果我们遇上了问题，那么可能是返回的 JSON 和我们所使用的类之间不匹配。

198
00:16:56,321 --> 00:16:59,131
这个小按钮应该能工作。

199
00:16:59,941 --> 00:17:03,569
我弄错了数据类型。

200
00:17:03,570 --> 00:17:06,790
所以我需要解决一下。

201
00:17:06,791 --> 00:17:17,018
我们尚未触发断点。如果我们触发了一个异常 (Exception)，那么我们应该考虑一下这些东西了。

202
00:17:25,089 --> 00:17:37,547
看上去很不错，让我们看一下 URL。我没法在屏幕右侧看全整个 URL，但是看上去是一个合规的 URL 。

203
00:17:38,028 --> 00:17:40,346
嗯，让我们继续，然后看看会发生什么。

204
00:17:43,338 --> 00:17:45,645
发送请求，得到结果

205
00:17:46,736 --> 00:17:48,705
把结果放入内存流，传入我们的反序列器中

206
00:17:48,706 --> 00:17:51,725
接下来我变得紧张。

207
00:17:51,726 --> 00:17:56,725
嗯，工作了。好极了！

208
00:17:59,105 --> 00:18:01,902
列出十条结果，让我们看一下其中的一个结果。

209
00:18:01,903 --> 00:18:03,882
“弗兰肯斯坦的怪物” ("Frankenstein's Monster") 。

210
00:18:03,883 --> 00:18:05,822
接下来我将告诉你我们下节课要做的事情。

211
00:18:07,503 --> 00:18:09,270
我对此很高兴。

212
00:18:09,271 --> 00:18:12,970
我们从漫威动画的 API 那取回了数据

213
00:18:12,971 --> 00:18:16,230
我为第一次尝试就取得成功感到激动。

214
00:18:16,231 --> 00:18:20,210
下节课我们将驾驭取回的数据

215
00:18:20,211 --> 00:18:24,010
我们将会绑定数据并使其显示在屏幕上。

216
00:18:24,011 --> 00:18:25,150
那会是非常令人激动的事情。

217
00:18:25,151 --> 00:18:27,591
下一节课程见。谢谢大家。

